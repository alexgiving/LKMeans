from typing import List, Tuple

import numpy as np


def move_towards_mean(mu: np.ndarray, mu_mean: np.ndarray, t: float) -> np.ndarray:
    '''
    Returns a new point that is moved towards the mean according to the rule:
    point(t) = point + t * (mean - point), 0 ≤ t ≤ 1
    '''
    new_mu = mu + t * (mu_mean - mu)
    return new_mu


def generate_2_mix_distribution(
    probability: float,
    mu_1: np.ndarray,
    mu_2: np.ndarray,
    cov_matrix_1: np.ndarray,
    cov_matrix_2: np.ndarray,
    n_samples: int,
    t: float
) -> Tuple[np.ndarray, np.ndarray]:
    '''
    Returns points from 2 gaussian distributions.
    Generated by distribution probability, covariation matrix and means vector.
    '''

    mu_mean = (mu_1 + mu_2) / 2

    n_1 = int(probability * n_samples)
    mu_2 = move_towards_mean(mu_2, mu_mean, t)

    n_2 = n_samples - n_1
    mu_1 = move_towards_mean(mu_1, mu_mean, t)

    distribution_1 = np.random.multivariate_normal(
        np.squeeze(mu_1, axis=0), cov_matrix_1, n_1)
    distribution_2 = np.random.multivariate_normal(
        np.squeeze(mu_2, axis=0), cov_matrix_2, n_2)

    samples = np.concatenate((distribution_1, distribution_2), axis=0)
    labels = np.concatenate((np.zeros(n_1), np.ones(n_2)))

    # Shuffle the samples and labels
    permutation = np.random.permutation(n_samples)
    samples = samples[permutation]
    labels = labels[permutation]

    return samples, labels


def generate_mix_distribution(
    probability: float,
    mu_list: List[np.ndarray],
    cov_matrix_list: List[np.ndarray],
    n_samples: int,
    t: float
) -> Tuple[np.ndarray, np.ndarray]:
    '''
    Returns points from gaussian distributions.
    Generated by distribution probability, covariation matrix and means vector.
    '''

    mu_mean = np.mean(mu_list, axis=0)

    modified_mu_list = []
    for mu in mu_list:
        modified_mu_list.append(move_towards_mean(mu, mu_mean, t))

    # need be dunamic
    if len(mu_list) == 2:
        n_1 = int(probability * n_samples)
        n_list = [n_1, n_samples - n_1]
    elif len(mu_list) == 3:
        n_1 = int(probability * n_samples)
        n_2 = int(probability * n_samples)
        n_3 = n_samples - n_1 - n_2
        n_list = [n_1, n_2, n_3]

    distributions = []
    for n, mu, cov_matrix in zip(n_list, modified_mu_list, cov_matrix_list):
        distribution = np.random.multivariate_normal(
            np.squeeze(mu, axis=0), cov_matrix, n)
        distributions.append(distribution)
    print(len(distributions))

    samples = np.concatenate(distributions, axis=0)

    labels = np.array([])
    for lable_id, n in enumerate(n_list):
        samples_labels = np.full(n, lable_id)
        labels = np.concatenate((labels, samples_labels))

    # Shuffle the samples and labels
    permutation = np.random.permutation(n_samples)
    samples = samples[permutation]
    labels = labels[permutation]

    return samples, labels
